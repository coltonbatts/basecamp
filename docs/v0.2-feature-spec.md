# Basecamp v0.2 Feature Spec

## 1) Product Thesis
Basecamp v0.2 turns the app from a persistent chat shell into an interactive cognitive IDE with explicit model agency, visible execution controls, and fast iteration loops.

v0.1 strength: local-first persistence and deterministic camp storage.
v0.2 goal: increase interaction depth between user, model, and app runtime.

## 2) Success Criteria
1. A user can run goal-oriented workflows (plan -> execute -> revise) without leaving the camp screen.
2. Model actions that change files or camp state are visible and user-controlled.
3. Users can branch/replay work quickly across models and preserve outcomes as artifacts.
4. Arena and Camp become connected, not isolated experiences.

## 3) v0.2 Scope (What Ships)

### A. Action Queue + Approval Flow
- Add a first-class action queue in Camp chat:
  - `proposed`: model suggests action
  - `approved`: user approves
  - `executing`: runtime executes
  - `done` / `failed`
- Every mutating action shows a preflight preview before write.
- Approval modes:
  - `manual` (default)
  - `auto-safe` (non-mutating actions auto-run, mutating still prompt)

### B. Expand Model Tool Surface
Current tools are filesystem-only (`read_file`, `list_files`, `write_file`).
Add app-native tools:
1. `list_artifacts`
2. `get_artifact`
3. `create_artifact`
4. `update_artifact`
5. `search_transcript`
6. `update_camp_prompt`
7. `update_camp_memory`
8. `append_note` (writes to notes file namespace, not arbitrary root)

Rules:
- Read tools can auto-run in `auto-safe` mode.
- Mutating tools require queue approval unless user opts into full auto-run.

### C. Artifact Composer in Active Chat Loop
- Wire artifact selection into composer (already scaffolded by `useArtifactComposerState`).
- Persist selected IDs on user message via `included_artifact_ids`.
- Increment artifact usage when included.
- Show selected artifact chips above composer with quick remove.

### D. Branch + Replay
Per assistant message actions:
1. `Branch Camp Here`
- creates new camp with copied config/context/artifacts
- transcript truncated through selected message
2. `Replay with Model...`
- re-run same user turn + active context against selected model
- append output as sibling assistant message

### E. Arena -> Camp Bridge
- Arena output cards get actions:
  - `Save as Artifact`
  - `Send to Camp`
  - `Open in New Camp`
- Users can promote Arena discoveries into persistent work in 1 click.

### F. Interaction Presets
Add run presets to chat composer:
- `Explore`
- `Build`
- `Critique`
- `Refactor`
Each preset sets temperature, max tokens, and default tool policy.

## 4) UX Flows

### Camp Send Flow (v0.2)
1. User writes prompt, selects artifacts/preset.
2. Runtime composes request with system prompt + memory + selected artifacts + transcript.
3. If model returns tool calls:
  - show queue rows with args preview
  - user approves/rejects
  - approved items execute and stream back as tool messages
4. Assistant final response appears with:
  - resolved model
  - token usage
  - actions: `Save Artifact`, `Branch Here`, `Replay`

### Approval UX Rules
- `read_file` / `list_files`: auto-run in `auto-safe`
- `write_file` / artifact mutations / prompt-memory updates: require explicit approval
- Bulk actions can be approved all-at-once

## 5) Data + Runtime Changes

### New local JSONL event line shape (optional but recommended)
Add message metadata fields:
- `meta.action_id`
- `meta.action_status`
- `meta.resolved_model`
- `meta.usage`

This keeps transcript append-only while preserving execution trace.

### Queue State
- UI state only for v0.2 initial release.
- Optional v0.2.1: persist queue log to `camp_actions.jsonl`.

## 6) File-by-File Implementation Map

### Routing and Top-Level
- `src/App.tsx`
  - Add routes for existing dormant views if kept (`/history`, `/run/:id`, `/compare/:leftId/:rightId`) OR remove dead components.
  - Add route for new `ActionQueueView` only if separate page is preferred; default inline queue in camp.

### Camp Workspace
- `src/views/MainLayout.tsx`
  - Add visible camp settings controls currently only in state:
    - `draftSystemPrompt`
    - `draftToolsEnabled`
  - Integrate artifact composer hook:
    - selected chips
    - query/filter drawer
    - include IDs on send
  - On send:
    - pass selected artifact bodies to `runCampChatRuntime`
    - append user message with `included_artifact_ids`
    - call `campIncrementArtifactUsage`
  - Add approval queue UI for tool calls and wire executor behavior.
  - Add assistant message actions: branch/replay/promote.

### Transcript Rendering
- `src/components/TranscriptView.tsx`
  - Add message action bar for assistant messages:
    - `Save Artifact`
    - `Branch Here`
    - `Replay`
  - Render execution badges (`tool used`, `resolved model`, `tokens`).
  - Render pending action queue items inline between assistant/tool messages.

### Runtime Orchestration
- `src/lib/campChatRuntime.ts`
  - Extend runtime input with approval callback:
    - `onToolCallProposed(toolCall) -> approve/reject`
  - Extend runtime result with:
    - `toolExecutionTrace`
    - `finalResolvedModel`
    - `finalUsage`
  - Ensure streaming behavior remains unchanged for non-tool runs.

### OpenRouter Loop
- `src/lib/openrouter.ts`
  - Keep transport layer responsibilities minimal.
  - Return richer loop iteration metadata to runtime layer:
    - per-iteration tool call count
    - per-iteration assistant text

### Tool Registry
- `src/lib/tools.ts`
  - Keep filesystem tools.
  - Add non-filesystem tool namespace wrappers that call db layer operations.
  - Add strict argument validation per new tool.

- `src/lib/tools/registry.ts`
  - Register new app-native tools and executors.
  - Add `toolKind` metadata (`read` | `mutate`) for approval policy.

### Data Access
- `src/lib/db.ts`
  - Expose already-available camp/artifact operations for tool executors.
  - Add transcript search helper if not present (`campSearchTranscript` or SQLite-backed index lookup).
  - Add `campBranchFromMessage` invoke wrapper once Rust command exists.

### Rust Backend
- `src-tauri/src/lib.rs`
  - Add commands:
    1. `camp_search_transcript`
    2. `camp_branch_from_message`
    3. `camp_replay_message` (optional if replay stays frontend-only)
  - Keep traversal/path validation model from existing context file commands.
  - Add tests for each new command, including path safety and transcript bounds.

### Arena Integration
- `src/views/ArenaView.tsx`
  - Add per-slot action buttons after run completion:
    - save result as artifact in selected camp
    - send result to camp chat
    - create new camp with selected output
  - Add target camp picker for promotions.

### Settings
- `src/components/Settings.tsx`
  - Add approval policy selector:
    - `manual`
    - `auto-safe`
    - `full-auto` (explicit warning)
  - Persist as setting in SQLite.

## 7) Acceptance Criteria

### AC1: Artifact Context Works in Composer
- Selecting artifacts modifies outgoing request context.
- User transcript line includes `included_artifact_ids`.
- Usage counts increment exactly once per send.

### AC2: Approval Queue Prevents Silent Mutations
- Mutating tool calls never execute without approval in `manual` / `auto-safe`.
- Rejected actions create a tool-result message indicating rejection.

### AC3: Branch + Replay Reduce Iteration Time
- Branch camp is created from selected message in <1s for small transcripts.
- Replay appends new assistant response without losing existing history.

### AC4: Arena Promotions Are One-Step
- Any finished Arena slot can become a camp artifact without copy/paste.

## 8) Rollout Plan

### Phase 1 (Core Interaction Depth)
1. Artifact composer wiring in Camp.
2. Approval queue for existing filesystem tools.
3. Message actions (`branch`, `replay`) UI scaffolding.

### Phase 2 (Tool Surface Expansion)
1. Add app-native artifact/camp tools.
2. Add transcript search and memory/prompt update tools.

### Phase 3 (Arena Bridge + Presets)
1. Arena promotion actions.
2. Composer presets and policy controls.

## 9) Non-Goals (v0.2)
- Autonomous background agents.
- Multi-user collaboration.
- Cloud sync.
- Complex code-diff patch engine.

## 10) Risks and Mitigations
1. Risk: Tool loop complexity harms reliability.
- Mitigation: keep max iteration cap; add deterministic queue state transitions.

2. Risk: UI becomes crowded.
- Mitigation: progressive disclosure (collapsed advanced controls by default).

3. Risk: write safety regressions.
- Mitigation: preserve existing path sandbox checks; add approval policy tests.

## 11) Execution Checklist
1. Wire artifact composer into `MainLayout` send path.
2. Add queue state model and rendering.
3. Gate mutating tool execution by approval policy.
4. Implement branch/replay backend/frontend actions.
5. Add Arena -> Camp promotion actions.
6. Add tests for new commands and runtime policy logic.
