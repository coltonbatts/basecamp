# Basecamp v0.1 Architecture

## Camp Folder Schema

Each camp is a visible local folder under:

`<workspace>/camps/<camp_id>/`

Files:

- `camp.json` - deterministic camp metadata and selected model
- `system_prompt.md` - editable system prompt text
- `memory.json` - structured memory JSON
- `transcript.jsonl` - append-only conversation log (`user`/`assistant`/`system`)
- `artifacts/index.json` - deterministic artifact metadata index
- `artifacts/<artifact_id>.md` - reusable markdown artifact body
- `context/` - optional additional files the user manages manually

`camp.json` shape:

```json
{
  "schema_version": "0.1",
  "id": "f8c2...",
  "name": "Planning",
  "model": "anthropic/claude-3.5-sonnet",
  "created_at": 1764000000000,
  "updated_at": 1764000500000
}
```

`transcript.jsonl` line shape:

```json
{"id":"...","role":"user","content":"...","created_at":1764000001000}
```

`user` transcript lines can additionally include:

```json
{"included_artifact_ids":["artifact-a","artifact-b"]}
```

## Artifacts and Progression (v0.1.1)

Artifacts are local markdown files promoted from transcript messages.

- Artifact IDs are UUIDs.
- Artifact markdown format is:
  - `# <title>`
  - blank line
  - source message body
- `artifacts/index.json` is pretty JSON and stores:
  - `schema_version: "0.1"`
  - `artifacts[]` metadata:
    - `id`
    - `title`
    - `filename`
    - `source_message_id`
    - `source_role`
    - `tags: string[]`
    - `created_at`
    - `updated_at`
    - `usage_count`
    - `archived` (optional status support)

Artifact context inclusion is deterministic:

1. system prompt (if present)
2. structured memory system message
3. selected artifact system messages sorted by title asc, then id asc
4. transcript messages
5. current user message (if provided separately)

Artifact system messages use:

- `Artifact: <title> (id: <id>)`
- followed by artifact markdown body

Truncation limits:

- max 8,000 chars per artifact body
- max 40,000 chars total across selected artifact bodies
- truncation marker is `[TRUNCATED]`

Progression is derived client-side from local camp data only:

- `artifact_count`
- `reused_artifact_count` (`usage_count > 0`)
- `conversation_turn_count` (user turns)

Labels:

- `0-2` artifacts -> `Basecamp`
- `3-7` artifacts -> `Ridge`
- `8+` artifacts -> `Summit`

## Rust-Side State Management

Rust does not keep hidden camp state in memory.

- Source of truth is always the camp files on disk.
- Tauri commands read/write files directly each call.
- Existing SQLite is still used for app settings and model cache.

Minimal Camp commands:

- `camp_list`
- `camp_create`
- `camp_load`
- `camp_update_config`
- `camp_update_system_prompt`
- `camp_update_memory`
- `camp_append_message`
- `camp_list_artifacts`
- `camp_get_artifact`
- `camp_create_artifact_from_message`
- `camp_update_artifact`
- `camp_increment_artifact_usage`
- `ensure_default_workspace` (auto-bootstraps `~/Basecamp` when unset)

Validation guarantees:

- Workspace path must be an existing directory
- `camp_id` disallows traversal/path separators
- Transcript roles limited to `system | user | assistant`
- Writes are deterministic JSON/MD/JSONL file writes

## React Layout (Minimal)

Four-pane workspace with a top-level Trailhead setup bar:

1. Camps pane
- List camps
- Select active camp

2. Config pane
- Model
- System prompt
- Structured memory JSON
- Save to local files

3. Transcript pane
- Render transcript
- Composer + streaming response
- Request composition preview

4. Artifact pane
- List artifacts from local index
- Promote transcript messages into artifacts
- Select artifacts for next send context

Visual constraints:

- Black background, white text
- Geist Pixel font
- Minimal controls and copy

## OpenRouter Request Composition

For each send:

1. Save current camp drafts to disk (`camp.json`, `system_prompt.md`, `memory.json`)
2. Append user message to `transcript.jsonl`
3. Reload camp from disk
4. Compose request messages in this order:

- `system_prompt.md` as first `system` message (if non-empty)
- `memory.json` as second `system` message (`Structured memory (JSON): ...`)
- selected artifact messages (deterministic sort + truncation rules)
- all transcript entries from `transcript.jsonl`
- current user message (already persisted in transcript for this flow)

5. Stream OpenRouter completion
6. Append assistant output to `transcript.jsonl`

Composition helper:

- `src/lib/campRequest.ts`
- `composeCampOpenRouterRequest({ camp, userMessage, temperature, maxTokens })`

Streaming helper:

- `src/lib/openrouter.ts`
- `streamOpenRouterChatCompletion(apiKey, payload, onToken)`
